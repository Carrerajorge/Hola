Implementa en el input del chat un sistema completo de paste/drag&drop universal para imágenes y documentos: en frontend captura paste (Ctrl+V / Cmd+V) y drop/dragover sobre la barra del chat (y opcionalmente toda el área del composer) usando addEventListener('paste', ...), addEventListener('dragover', e=>e.preventDefault()), addEventListener('drop', ...); en paste lee event.clipboardData.items y soporta (1) imágenes directas del portapapeles (item.type.startsWith('image/') → getAsFile()), (2) archivos pegados (clipboardData.files), y (3) texto/HTML pegado (text/plain/text/html) solo si no hay archivos (para no duplicar); en drop lee event.dataTransfer.files y también event.dataTransfer.items para soportar carpetas/drag desde Finder/Explorer (WebKit) usando webkitGetAsEntry() + recorrido recursivo para “directory drop” si lo queremos; normaliza todo a una cola de File/Blob con metadata (name, type, size, lastModified, source: 'paste'|'drop') y valida MIME real (no solo extensión), límites de tamaño y conteo, y lista allow/deny (p.ej. image/*, application/pdf, application/msword, application/vnd.openxmlformats-officedocument.*, text/plain, etc.); muestra un preview en el composer con thumbnails para imágenes (usando URL.createObjectURL(file) + revoke), iconos para documentos, progreso por archivo, y acciones “remover/reordenar”; al enviar el mensaje sube archivos con multipart/form-data (o chunked/resumable si >X MB) a un endpoint /uploads que devuelve fileId, url y sha256 para dedupe; luego envía el mensaje al endpoint /messages referenciando attachments:[{id,fileName,mime,size,width,height,thumbUrl}]; en backend valida nuevamente tipo/tamaño, escanea si aplica, almacena en object storage (S3/GCS) con claves únicas, genera thumbnails para imágenes (y previews de PDF si se requiere), y retorna metadatos; asegura que el comportamiento sea consistente: si el usuario pega una imagen desde screenshot se adjunta automáticamente como archivo, si pega texto + archivos, los archivos prevalecen (o se adjuntan ambos con regla clara), dragover muestra estado visual, y evita navegación accidental bloqueando drop default en toda la ventana cuando el objetivo no sea un input permitido.