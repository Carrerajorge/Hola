Enfócate únicamente en la herramienta de Agente (sin tocar la arquitectura/UI del chat ni romper endpoints existentes) y haz un hardening + correctness pass con auditoría que además identifique y liste los problemas actuales (bugs, flakiness, race conditions, gaps vs spec) y los corrija con evidencia: (1) Audit report primero: genera test_results/agent_audit_report.md enumerando hallazgos por severidad (P0/P1/P2) y dónde ocurren (archivo/ruta), incluyendo: inconsistencias de contratos, estados inválidos, duplicación de runs, cancelación que no aborta, fugas de recursos, eventos desordenados/duplicados, RBAC bypass, y regresiones; (2) Contract enforcement: Zod strict en todos los boundaries (POST/GET agent, tool I/O, events) + AgentRunSchema/AgentStepSchema/AgentEventSchema/ArtifactSchema con validación runtime y errores tipados; agrega golden snapshot tests para responses y eventos; (3) StateMachine correctness: define transiciones válidas y asegúrate por unit tests que transiciones inválidas fallan; persiste cambios con transacciones DB + optimistic locking (version column) para prevenir doble update; (4) Idempotency & dedupe: implementa idempotency persistente (idempotency_keys con TTL) para POST /api/agent/runs y tool calls, y prueba que requests duplicados no crean runs/steps duplicados; (5) Cancel/Pause/Retry reales: instrumenta cancellation tokens propagados hasta workers/sandbox/tools (abort real, cleanup), pause/resume que detenga ejecución, y retry con attempt/retry_count y backoff; demuestra con tests (step largo) que cancel aborta y libera recursos; (6) Event stream robusto: GET /api/agent/runs/:id/events con ordering garantizado (monotonic sequence), paginación ?after=, idempotencia de eventos, y soporte de reanudación (SSE Last-Event-ID); tests para no duplicar ni perder eventos; (7) ToolRegistry/PolicyEngine: enumera tools/capabilities y aplica PolicyEngine deny-by-default por RBAC/plan + human-in-the-loop gate para acciones sensibles; agrega tests de bypass y prompt-injection (el agente no debe ejecutar tools por instrucciones en documentos sin validación); (8) Resiliencia & performance: scheduler/worker con timeouts por step/tool, retries con backoff+jitter, circuit breaker, DLQ, recovery tras restart (re-hidratar runs en running → queued), y benchmarks (npm run perf:agent) con umbrales p95/p99 + soak (≥100 runs concurrentes con mocks) guardando outputs en test_results/agent_*; (9) No regressions: E2E Playwright que pruebe que el chat normal no cambia y el modo agent funciona completo (plan 3–8 pasos, multi-tool, artifacts, pause/resume/cancel/retry); (10) Exit criteria: no termines hasta que npm run test:all, npm run agent:certify, benchmarks y soak pasen sin flaky tests, y actualiza replit.md con checklist 100% ✅ + links a outputs y lista exacta de archivos tocados.