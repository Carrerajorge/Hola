Actúa como ingeniero full‑stack senior y trabaja sobre ESTE repositorio (no inventes archivos que no existan; primero inspecciona la estructura y decide el stack real: Office Add‑in con Office.js/React/Vite/Next/Node, etc.), e implementa una herramienta llamada “Instrucciones” en el panel lateral (tipo ChatGPT) para PowerPoint que permita: (1) cuando el usuario seleccione “Instrucciones”, mostrar un formulario/chat donde el usuario escribe el tema y requisitos de la PPT (audiencia, objetivo, tono, idioma, nivel técnico, estilo “minimalista profesional”, paleta opcional, tipo de presentación, cantidad de diapositivas = 12 por defecto, y si debe incluir gráficos y código), y además un componente de subida múltiple de archivos (PDF/DOCX/TXT/MD/PPTX/CSV/XLSX e imágenes JPG/PNG/WebP); (2) al presionar “Generar”, crear un RUN idempotente para evitar duplicaciones (generar client_request_id UUID, guardar run con status pending→processing→done, bloquear con UPDATE…WHERE status='pending' RETURNING…, y poner UNIQUE(conversation_id,client_request_id) en BD o storage; deshabilitar el botón mientras processing; si llega el mismo client_request_id devolver el resultado existente sin volver a llamar al modelo ni reinsertar diapositivas); (3) backend/pipeline: recibir multipart, guardar temporalmente, extraer texto y tablas (pdf-parse, mammoth para docx, xlsx para excel, csv-parse; para PPTX extraer texto si aplica; para imágenes generar preview con sharp y obtener descripción con el modelo multimodal si está disponible), resumir/normalizar contenido en “SourcePack” (texto clave, bullets, secciones, datos tabulares, lista de imágenes con captions) limitando tokens (chunk+map-reduce); (4) llamar al modelo (el que ya usa el repo, p.ej. Gemini 3 Flash) con un prompt estricto para producir un JSON validable “PresentationSpec” (usa Zod/JSON Schema y reintenta si no cumple) con exactamente 12 slides y un sistema de diseño minimalista: cada slide incluye layout (title/section/two-column/image-focus/chart/code/summary), title, bullets (máx 5, cortos), notas del orador, assets referenciados (image_id) y, si hay datos, al menos 2 slides con gráficos; (5) generación de gráficos “con código”: para cada chart slide generar (a) un objeto de configuración (Chart.js config o similar) y (b) renderizarlo a PNG server-side usando chartjs-node-canvas (o alternativa compatible) y también guardar el snippet de código (config) para insertarlo en la diapositiva en una caja monoespaciada o en notas; (6) generar la presentación: opción A preferida para renderizar “en el lado de la PPT” (dentro de PowerPoint) = crear un PPTX con PptxGenJS (layout 16:9, márgenes consistentes, tipografías seguras como Aptos/Calibri, estilo blanco/negro con un color acento, grids, alineación y espaciado profesional) y devolver base64; en el cliente Office.js insertar las diapositivas en la presentación actual con context.presentation.insertSlidesFromBase64(base64, opciones) para que aparezcan en miniaturas automáticamente; si el repo ya crea shapes con Office.js, entonces genera slides directamente con PowerPoint.run pero mantén el mismo diseño; (7) UX: mostrar barra de progreso por etapas (Extrayendo→Planificando→Generando→Insertando), mostrar preview/lista de archivos cargados, y al finalizar enfocar la primera slide insertada; (8) calidad “pro”: incluye portada, agenda, 2–3 slides de contenido con imágenes relevantes (si hay), 2 slides con gráficos basados en datos reales del documento (si no hay datos, crea un gráfico simple con datos inferidos y aclara en notas), 1 slide con “Conclusiones”, 1 slide “Siguientes pasos”, y 1 slide “Fuentes/Referencias” (citando nombres de archivos cargados); (9) seguridad/robustez: límites de tamaño de archivos, manejo de errores con mensajes claros, timeouts, logs; (10) entrega: implementa paso a paso con cambios de código concretos (componentes UI, endpoints, módulos de extracción, schema validation, generador pptx, inserción Office.js, idempotencia/locks), agrega README corto de configuración (API keys, variables de entorno) y al menos 2 pruebas/fixtures (un CSV + una imagen) para validar que siempre se crean exactamente 12 diapositivas sin duplicar aunque haya reintentos/reloads.