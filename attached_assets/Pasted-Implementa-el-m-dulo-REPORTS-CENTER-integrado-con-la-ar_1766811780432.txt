Implementa el módulo REPORTS CENTER integrado con la arquitectura existente del dashboard, consumiendo datos reales de los módulos ya implementados (Users, AI Models, Payments, Invoices, Analytics, Database, Security): 1) INTEGRACIÓN CON MÓDULOS EXISTENTES - conectar con endpoints actuales: GET /api/users para reportes de usuarios (total_users, users_by_plan, users_by_status, users_by_role, signups_over_time, churn_rate), GET /api/ai-models para reportes de modelos (requests_by_model, tokens_by_model, latency_by_model, cost_by_model, error_rate_by_model, model_usage_trend), GET /api/payments para reportes financieros (revenue_by_period, revenue_by_plan, revenue_by_model, payments_by_status, payments_by_method, refunds, failed_payments), GET /api/invoices para reportes de facturación (invoices_by_status, aging_buckets_30_60_90, outstanding_amount, paid_vs_pending, overdue_alerts), GET /api/analytics para métricas agregadas (dau_wau_mau, session_metrics, conversion_funnel, retention_cohorts, feature_usage), GET /api/db/stats para reportes de database (table_sizes, query_performance, connection_usage, replication_status, storage_growth), GET /api/security/audit-logs para reportes de seguridad (auth_events, permission_changes, api_key_usage, suspicious_activities, compliance_status). 2) REPORT TYPES ESPECÍFICOS PARA TU SOFTWARE - crear reportes pre-construidos: USER_REPORT (columns: user_id mod, email, name, plan, role, status, queries_total, tokens_consumed, total_spent, signup_date, last_active; filters: date_range, plan, status, role; grouping: by_plan, by_country, by_signup_month), AI_MODELS_REPORT (columns: model_name, provider, status, total_requests, total_tokens, avg_latency_ms, error_rate, total_cost, revenue_generated, margin_percentage; filters: date_range, provider, status; grouping: by_provider, by_day), FINANCIAL_REPORT (columns: transaction_id, customer, amount, method, status, model_used, tokens_charged, date; aggregations: total_revenue, avg_transaction, revenue_by_plan, revenue_by_model, mrr, arr; filters: date_range, status, method, plan), INVOICE_REPORT (columns: invoice_id, customer, amount, status, due_date, days_overdue, issued_date; aggregations: total_invoiced, total_paid, total_pending, total_overdue, aging_summary; filters: date_range, status, customer), USAGE_REPORT (columns: user_email, model_used, requests_count, tokens_in, tokens_out, total_cost, date; aggregations: total_requests, total_tokens, cost_per_user, top_10_users; filters: date_range, user, model), SECURITY_REPORT (columns: timestamp, action_type, actor_email, actor_ip, resource_type, resource_id, status, severity; aggregations: events_by_type, events_by_severity, failed_logins_count, suspicious_count; filters: date_range, action_type, severity, actor), CONVERSATIONS_REPORT (columns: conversation_id, user_email, started_at, messages_count, tokens_used, model, duration_seconds, status; aggregations: total_conversations, avg_messages, avg_tokens, avg_duration; filters: date_range, user, model, status). 3) REPORT GENERATION ENGINE - crear servicio ReportGenerator class con métodos: generateReport(report_type, filters, format), que internamente llama a los endpoints correspondientes, aplica filtros, ejecuta agregaciones, y formatea output; usar Promise.all para queries paralelas cuando reporte necesita múltiples fuentes; implementar caching con Map o Redis para reportes frecuentes (TTL 5min para real-time, 1hr para historical); progress tracking con state: {status: 'querying'|'processing'|'formatting'|'complete', progress: 0-100, current_step, rows_processed}. 4) EXPORT FORMATS INTEGRADOS - PDF: usar @react-pdf/renderer con template que incluya logo de tu software, título del reporte, fecha de generación, filtros aplicados, tabla de datos con estilos consistentes con tu dark theme (#0a0a0f background, #6366f1 accent), gráficos renderizados como imágenes; CSV: usar papaparse para generar con headers, proper escaping, UTF-8 BOM; Excel: usar sheetjs/xlsx con sheets separados (Summary, Details, Charts data), formatted headers, number formatting para currency/percentages; JSON: structured output con metadata {report_type, generated_at, filters, total_rows} + data[]. 5) SCHEDULED REPORTS - crear tabla scheduled_reports en tu DB: {id, report_type, name, filters_config: JSON, schedule: {frequency: 'daily'|'weekly'|'monthly', day_of_week, time_utc}, output_format, recipients: [{email, notify_only}], is_enabled, last_run, next_run, created_by}; implementar cron job (node-cron) que cada minuto chequea scheduled_reports WHERE is_enabled=true AND next_run <= NOW(), ejecuta generación, envía por email (nodemailer con tu SMTP config), actualiza last_run y calcula next_run. 6) UI COMPONENTS CONSISTENTES - usar mismos estilos del dashboard existente: StatCard para métricas de reportes (total_generated, scheduled_active, storage_used), DataTable para listado de reportes con columns sortables, StatusBadge para status (ready/generating/failed/scheduled), Button variants (primary gradient, secondary outline) para acciones, Modal para configuración y preview, mismo color scheme (#0a0a0f, #12121a, #1a1a24, #6366f1, #8b5cf6, #22d3ee), tipografía (DM Sans body, Space Grotesk headers/numbers). 7) REPORTS DASHBOARD VIEW - tabs: [All Reports, Scheduled, History]; sección QUICK REPORTS con cards para cada report_type mostrando: icon, name, description, last_generated timestamp, [Generate Now] button; sección SCHEDULED REPORTS con tabla: report_name, frequency, next_run, last_run, status, recipients_count, actions (edit/pause/delete); sección GENERATION HISTORY con tabla: report_name, generated_at, generated_by (user o 'Scheduled'), rows, size, format, [Download] button; filtros en sidebar: report_type, date_range, generated_by. 8) REPORT CONFIGURATION MODAL - cuando user clickea configure en cualquier reporte: form con fields dinámicos según report_type, date_range picker (preset: today, yesterday, last_7_days, last_30_days, this_month, last_month, custom), filtros específicos del reporte (dropdowns poblados desde tus endpoints existentes, ej: plan_filter populated from GET /api/users/plans), output_format selector (PDF/CSV/Excel/JSON), preview button que muestra sample 10 rows, [Generate] button que triggerea generación. 9) REAL-TIME GENERATION PROGRESS - cuando se genera reporte: modal con progress bar, steps indicator (Fetching Users... → Fetching Payments... → Processing 45K rows... → Generating PDF... → Complete), elapsed_time counter, cancel button; al completar: auto-download del file + toast notification "Report generated successfully", guardar en history. 10) REPORT VIEWER INLINE - para reportes ya generados: modal fullscreen con tabs [Table View, Chart View, Raw Data]; Table View con sorting client-side, search, pagination; Chart View renderiza gráficos relevantes (line para trends, pie para distributions, bar para comparisons) usando Recharts ya instalado; acciones: [Download PDF] [Download CSV] [Download Excel] [Share Link] [Email Report] [Print]. 11) STATE MANAGEMENT - crear ReportsContext con: {reports: [], scheduled: [], history: [], generating: {report_id, progress, status}, filters: {}}; actions: fetchReports, generateReport, scheduleReport, deleteScheduled, downloadReport; persistir filters en localStorage para mantener preferencias del usuario. 12) API ENDPOINTS NUEVOS - POST /api/reports/generate (body: {report_type, filters, format}) retorna {job_id, status}; GET /api/reports/status/:job_id retorna {status, progress, download_url si complete}; GET /api/reports/history retorna generated reports; POST /api/reports/schedule crea scheduled report; GET /api/reports/scheduled lista scheduled; DELETE /api/reports/scheduled/:id elimina; GET /api/reports/download/:id retorna file stream con Content-Disposition header. 13) INTEGRATION HOOKS - crear custom hooks: useReportGenerator(report_type) retorna {generate, isGenerating, progress, result, error}; useScheduledReports() retorna {scheduled, create, update, delete, toggle}; useReportHistory(filters) retorna {history, isLoading, refetch}; useReportDownload() retorna {download, isDownloading}. 14) ERROR HANDLING - si endpoint fuente falla: mostrar partial report con warning "Some data unavailable: [source]", log error para debugging, retry automático 1 vez; si generación falla: update status to 'failed', mostrar error message, ofrecer retry; timeout de 5min para reportes largos con opción de "Generate in background & notify". 15) STORAGE & CLEANUP - guardar reportes generados en /tmp o configured storage path, metadata en DB (id, report_type, file_path, size_bytes, generated_at, expires_at), cleanup job que elimina files donde expires_at < NOW() (default retention 7 days, configurable), mostrar storage_used en dashboard con warning si >80% of limit.