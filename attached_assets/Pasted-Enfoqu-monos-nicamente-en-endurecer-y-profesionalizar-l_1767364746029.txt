Enfoquémonos únicamente en endurecer y profesionalizar la herramienta ‘Agente’ ya implementada, sin modificar la arquitectura/UI del chat ni romper endpoints existentes: refactoriza el Agente como un plugin modular con límites claros (AgentOrchestrator + ToolRegistry + StateMachine) y contratos tipados (TypeScript) para Run/Step/ToolCall/Artifact; implementa una máquina de estados explícita para runs y steps (queued → planning → running → verifying → done | failed | cancelled | paused) con transiciones válidas y persistencia transaccional en DB (Postgres) usando agent_runs y agent_steps con índices por chatId/messageId/runId, created_at, y status, además de idempotency keys por request para evitar duplicados; agrega event sourcing ligero: tabla agent_events (append-only) o un log JSONB por step para auditoría (tool_name, input_hash, output_ref, duration_ms, error_code, retry_count) y un correlationId global; el ToolRegistry debe soportar capabilities (e.g. requires_network, produces_artifacts, reads_files) y policy enforcement por RBAC/plan (free/pro/admin) con un PolicyEngine (deny-by-default para herramientas sensibles) y un human-in-the-loop gate (confirmación) antes de acciones de alto riesgo; mejora el planner con decomposition + tool selection (ReAct/plan-and-execute) pero fuerza salida estructurada vía Zod schemas (PlanSchema, StepSchema, ToolCallSchema, ArtifactSchema) y valida en runtime para evitar JSON inválido; implementa scheduler/worker robusto (bullmq/pg-boss/queue interna) con reintentos exponenciales, backoff, timeouts por tool, circuit breaker para tools inestables, y cancellation tokens reales (cancel/abort propagation hasta el sandbox y polling); estandariza outputs por tool a {artifacts[], previews[], logs[], metrics[]} y asegura que el chat solo muestre el card/side-panel leyendo el estado via GET /api/agent/runs/:id + GET /api/agent/runs/:id/events con polling/streaming SSE compatible con lo ya usado; añade observabilidad: logs estructurados (pino/winston), métricas por step (latency, success_rate, tool_error_rate), y trazas por runId/stepId; finalmente, crea una batería de tests deterministas: unit (validación de contratos, transiciones, policy), integration (endpoints agent + DB + cola), y E2E (Playwright) que prueben que (1) chat normal no cambia, (2) modo agent setea mode='agent', (3) genera plan 3–8 pasos, (4) ejecuta tools existentes (Excel multi-hoja/analyze/web/image/document) con artefactos, (5) pause/resume/cancel/retry funcionan, y (6) no hay llamadas reales al LLM en test (mocks), dejando npm run test:all verde y un changelog con lista exacta de archivos tocados y justificación técnica de cada mejora.