import type { TraceEvent } from "./runStreamClient";

export interface NarrationMetrics {
  // Plan
  providers: string[];
  yearStart: number;
  yearEnd: number;
  target: number;

  // Search
  currentProvider: string;
  queryIdx: number;
  queryTotal: number;
  page: number;
  foundInQuery: number;
  candidatesTotal: number;

  // Filter
  regions: string[];
  geoMismatch: number;
  yearOutOfRange: number;
  duplicate: number;
  lowRelevance: number;

  // Verify
  checked: number;
  ok: number;
  dead: number;

  // Accept
  accepted: number;

  // Export
  columnsCount: number;
  rowsWritten: number;
  filename: string;

  // Complete
  rejectedTotal: number;
}

export interface NarrationState {
  currentNarration: string;
  phase: string;
  lastUpdated: number;
  metrics: NarrationMetrics;
}

const NARRATION_TEMPLATES = {
  planning: "Estoy preparando el plan: fuentes={providers}, años={yearStart}-{yearEnd}, objetivo={target} artículos.",
  search: "Buscando en {provider}: consulta {queryIdx}/{queryTotal}, página {page}; encontrados +{found} (total {candidatesTotal}).",
  filter: "Aplicando filtros: región={regions} y años={yearStart}-{yearEnd}; descartados: región {geoMismatch}, año {yearOutOfRange}, duplicados {duplicate}, baja relevancia {lowRelevance}.",
  verify: "Verificando enlaces/DOI: {checked} revisados, {ok} válidos, {dead} caídos.",
  accept: "Seleccionados {accepted}/{target}; sigo hasta completar el objetivo.",
  export: "Generando Excel con {columnsCount} columnas: fila {rowsWritten}/{target}…",
  complete: "Listo: exporté {filename} y reporte de descartes ({rejectedTotal} descartados)."
};

const PHASE_FALLBACKS: Record<string, string> = {
  planning: "Planificando búsqueda…",
  signals: "Buscando artículos…",
  verification: "Verificando enlaces…",
  enrichment: "Enriqueciendo metadatos…",
  export: "Generando archivo…",
  finalization: "Finalizando…"
};

function createDefaultMetrics(): NarrationMetrics {
  return {
    providers: [],
    yearStart: 0,
    yearEnd: 0,
    target: 0,
    currentProvider: "",
    queryIdx: 0,
    queryTotal: 0,
    page: 0,
    foundInQuery: 0,
    candidatesTotal: 0,
    regions: [],
    geoMismatch: 0,
    yearOutOfRange: 0,
    duplicate: 0,
    lowRelevance: 0,
    checked: 0,
    ok: 0,
    dead: 0,
    accepted: 0,
    columnsCount: 0,
    rowsWritten: 0,
    filename: "",
    rejectedTotal: 0,
  };
}

function createDefaultState(): NarrationState {
  return {
    currentNarration: "",
    phase: "idle",
    lastUpdated: 0,
    metrics: createDefaultMetrics(),
  };
}

function interpolateTemplate(template: string, values: Record<string, string | number | string[]>): string {
  return template.replace(/\{(\w+)\}/g, (_, key) => {
    const value = values[key];
    if (Array.isArray(value)) {
      return value.join(", ");
    }
    return String(value ?? "");
  });
}

function generateNarration(phase: string, metrics: NarrationMetrics): string {
  switch (phase) {
    case "planning":
      if (metrics.providers.length > 0 || metrics.target > 0) {
        return interpolateTemplate(NARRATION_TEMPLATES.planning, {
          providers: metrics.providers,
          yearStart: metrics.yearStart,
          yearEnd: metrics.yearEnd,
          target: metrics.target,
        });
      }
      return PHASE_FALLBACKS.planning;

    case "signals":
      if (metrics.currentProvider || metrics.queryIdx > 0) {
        return interpolateTemplate(NARRATION_TEMPLATES.search, {
          provider: metrics.currentProvider,
          queryIdx: metrics.queryIdx,
          queryTotal: metrics.queryTotal,
          page: metrics.page,
          found: metrics.foundInQuery,
          candidatesTotal: metrics.candidatesTotal,
        });
      }
      return PHASE_FALLBACKS.signals;

    case "verification":
      if (metrics.checked > 0) {
        return interpolateTemplate(NARRATION_TEMPLATES.verify, {
          checked: metrics.checked,
          ok: metrics.ok,
          dead: metrics.dead,
        });
      }
      return PHASE_FALLBACKS.verification;

    case "enrichment":
      return PHASE_FALLBACKS.enrichment;

    case "export":
      if (metrics.columnsCount > 0 || metrics.rowsWritten > 0) {
        return interpolateTemplate(NARRATION_TEMPLATES.export, {
          columnsCount: metrics.columnsCount,
          rowsWritten: metrics.rowsWritten,
          target: metrics.target,
        });
      }
      return PHASE_FALLBACKS.export;

    case "finalization":
      if (metrics.filename) {
        return interpolateTemplate(NARRATION_TEMPLATES.complete, {
          filename: metrics.filename,
          rejectedTotal: metrics.rejectedTotal,
        });
      }
      return PHASE_FALLBACKS.finalization;

    default:
      return PHASE_FALLBACKS[phase] || "";
  }
}

function extractMetricsFromEvent(
  event: TraceEvent,
  currentMetrics: NarrationMetrics
): Partial<NarrationMetrics> {
  const updates: Partial<NarrationMetrics> = {};

  switch (event.event_type) {
    case "run_started":
      if (event.evidence?.target !== undefined) {
        updates.target = event.evidence.target;
      }
      break;

    case "plan_created":
      if (event.evidence?.year_start !== undefined) {
        updates.yearStart = event.evidence.year_start;
      }
      if (event.evidence?.year_end !== undefined) {
        updates.yearEnd = event.evidence.year_end;
      }
      if (event.evidence?.target !== undefined) {
        updates.target = event.evidence.target;
      }
      if (event.evidence?.regions) {
        updates.regions = event.evidence.regions;
      }
      break;

    case "search_progress":
      if (event.metrics?.queries_current !== undefined) {
        updates.queryIdx = event.metrics.queries_current;
      }
      if (event.metrics?.queries_total !== undefined) {
        updates.queryTotal = event.metrics.queries_total;
      }
      if (event.metrics?.pages_searched !== undefined) {
        updates.page = event.metrics.pages_searched;
      }
      if (event.metrics?.candidates_found !== undefined) {
        updates.foundInQuery = event.metrics.candidates_found - currentMetrics.candidatesTotal;
        updates.candidatesTotal = event.metrics.candidates_found;
      }
      break;

    case "filter_progress":
      if (event.metrics) {
        const m = event.metrics as Record<string, number | undefined>;
        if (m.geo_mismatch !== undefined) updates.geoMismatch = m.geo_mismatch;
        if (m.year_out_of_range !== undefined) updates.yearOutOfRange = m.year_out_of_range;
        if (m.duplicate !== undefined) updates.duplicate = m.duplicate;
        if (m.low_relevance !== undefined) updates.lowRelevance = m.low_relevance;
      }
      break;

    case "verify_progress":
      if (event.metrics) {
        const m = event.metrics as Record<string, number | undefined>;
        if (m.checked !== undefined) updates.checked = m.checked;
        if (m.ok !== undefined) updates.ok = m.ok;
        if (m.dead !== undefined) updates.dead = m.dead;
      }
      break;

    case "accepted_progress":
      if (event.metrics?.articles_accepted !== undefined) {
        updates.accepted = event.metrics.articles_accepted;
      }
      break;

    case "artifact_declared":
    case "artifact_generating":
      if (event.message) {
        const match = event.message.match(/([^/\\]+\.(xlsx|csv|pdf))$/i);
        if (match) {
          updates.filename = match[1];
        }
      }
      break;

    case "export_progress":
      if (event.metrics) {
        const m = event.metrics as Record<string, number | undefined>;
        if (m.columns_count !== undefined) updates.columnsCount = m.columns_count;
        if (m.rows_written !== undefined) updates.rowsWritten = m.rows_written;
      }
      break;

    case "run_completed":
      if (event.evidence?.final_url) {
        const match = event.evidence.final_url.match(/([^/\\]+\.(xlsx|csv|pdf))$/i);
        if (match) {
          updates.filename = match[1];
        }
      }
      if (event.metrics?.reject_count !== undefined) {
        updates.rejectedTotal = event.metrics.reject_count;
      }
      break;

    case "source_collected":
      if (event.metrics?.candidates_found !== undefined) {
        updates.candidatesTotal = event.metrics.candidates_found;
      }
      break;

    case "source_verified":
      if (event.metrics?.articles_verified !== undefined) {
        updates.ok = event.metrics.articles_verified;
        updates.checked = (currentMetrics.checked || 0) + 1;
      }
      break;

    case "source_rejected":
      if (event.metrics?.reject_count !== undefined) {
        updates.rejectedTotal = event.metrics.reject_count;
      }
      updates.dead = (currentMetrics.dead || 0) + 1;
      updates.checked = (currentMetrics.checked || 0) + 1;
      break;
  }

  return updates;
}

export function processEventForNarration(
  event: TraceEvent,
  currentState: NarrationState
): NarrationState {
  const now = Date.now();
  const phaseChanged = event.phase && event.phase !== currentState.phase;
  const timeSinceLastUpdate = now - currentState.lastUpdated;
  const shouldUpdate = phaseChanged || timeSinceLastUpdate >= 1000;

  const metricUpdates = extractMetricsFromEvent(event, currentState.metrics);
  const newMetrics: NarrationMetrics = {
    ...currentState.metrics,
    ...metricUpdates,
  };

  const newPhase = event.phase || currentState.phase;

  if (!shouldUpdate) {
    return {
      ...currentState,
      phase: newPhase,
      metrics: newMetrics,
    };
  }

  const newNarration = generateNarration(newPhase, newMetrics);

  return {
    currentNarration: newNarration,
    phase: newPhase,
    lastUpdated: now,
    metrics: newMetrics,
  };
}

export class NarrationAgent {
  private state: NarrationState;
  private lastEmitTime: number = 0;
  private lastPhase: string = "";

  constructor(initialState?: Partial<NarrationState>) {
    this.state = {
      ...createDefaultState(),
      ...initialState,
      metrics: {
        ...createDefaultMetrics(),
        ...initialState?.metrics,
      },
    };
    this.lastPhase = this.state.phase;
  }

  processEvent(event: TraceEvent): NarrationState {
    const now = Date.now();
    const phaseChanged = event.phase !== undefined && event.phase !== this.lastPhase;
    const timeSinceLastEmit = now - this.lastEmitTime;
    const shouldEmit = phaseChanged || timeSinceLastEmit >= 1000;

    const metricUpdates = extractMetricsFromEvent(event, this.state.metrics);
    this.state.metrics = {
      ...this.state.metrics,
      ...metricUpdates,
    };

    if (event.phase) {
      this.state.phase = event.phase;
    }

    if (shouldEmit) {
      this.state.currentNarration = generateNarration(this.state.phase, this.state.metrics);
      this.state.lastUpdated = now;
      this.lastEmitTime = now;
      this.lastPhase = this.state.phase;
    }

    return { ...this.state };
  }

  getCurrentNarration(): string {
    return this.state.currentNarration;
  }

  getMetrics(): NarrationMetrics {
    return { ...this.state.metrics };
  }

  getState(): NarrationState {
    return { ...this.state };
  }

  reset(): void {
    this.state = createDefaultState();
    this.lastEmitTime = 0;
    this.lastPhase = "";
  }
}
