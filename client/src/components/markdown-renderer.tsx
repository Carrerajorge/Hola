import React, { memo, useMemo, useState, useCallback, useRef, useEffect, Component, ErrorInfo, ReactNode } from "react";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import remarkMath from "remark-math";
import rehypeKatex from "rehype-katex";
import rehypeHighlight from "rehype-highlight";
import rehypeSanitize, { defaultSchema } from "rehype-sanitize";
import DOMPurify from "dompurify";
import { cn } from "@/lib/utils";
import { Check, Copy, Loader2, Download, Maximize2, Minimize2, FileText, FileSpreadsheet, Presentation, ChevronRight, Globe, ExternalLink } from "lucide-react";
import { preprocessMathInMarkdown } from "@/lib/mathParser";
import { CodeBlockShell } from "./code-block-shell";
import { isLanguageRunnable } from "@/lib/sandboxApi";
import { useSandboxExecution } from "@/hooks/useSandboxExecution";

const InlineSourceBadge = memo(function InlineSourceBadge({ name, url }: { name: string; url: string }) {
  const [showTooltip, setShowTooltip] = useState(false);
  const [imageError, setImageError] = useState(false);
  
  let domain = "";
  try {
    const urlObj = new URL(url);
    domain = urlObj.hostname.replace(/^www\./, "");
  } catch {
    domain = name.toLowerCase().replace(/\s+/g, "");
  }
  
  const faviconUrl = `https://www.google.com/s2/favicons?domain=${domain}&sz=32`;
  
  return (
    <span className="relative inline-block align-baseline">
      <a
        href={url}
        target="_blank"
        rel="noopener noreferrer"
        className={cn(
          "inline-flex items-center gap-1 px-2 py-0.5 ml-1",
          "text-xs font-medium rounded-full",
          "bg-muted/80 hover:bg-accent",
          "border border-border/50 hover:border-primary/40",
          "text-muted-foreground hover:text-foreground",
          "transition-all duration-200 cursor-pointer",
          "no-underline hover:no-underline"
        )}
        onMouseEnter={() => setShowTooltip(true)}
        onMouseLeave={() => setShowTooltip(false)}
        data-testid={`source-badge-${name.toLowerCase().replace(/\s+/g, '-')}`}
      >
        {!imageError ? (
          <img
            src={faviconUrl}
            alt=""
            className="w-3 h-3 rounded-full object-contain"
            onError={() => setImageError(true)}
          />
        ) : (
          <Globe className="w-3 h-3" />
        )}
        <span className="max-w-[100px] truncate">{name}</span>
      </a>
      
      {showTooltip && (
        <div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 z-50 pointer-events-none">
          <div className="bg-popover border border-border rounded-lg shadow-lg p-2 min-w-[160px] max-w-[240px]">
            <div className="flex items-center gap-2">
              {!imageError ? (
                <img src={faviconUrl} alt="" className="w-4 h-4 rounded-full object-contain" />
              ) : (
                <Globe className="w-4 h-4 text-muted-foreground" />
              )}
              <div className="flex-1 min-w-0">
                <p className="font-medium text-xs text-foreground truncate">{name}</p>
                <p className="text-[10px] text-muted-foreground truncate">{domain}</p>
              </div>
            </div>
          </div>
        </div>
      )}
    </span>
  );
});

function preprocessSourceBadges(content: string, webSources?: Array<{ url: string; siteName?: string; domain: string }>): string {
  let processed = content;
  
  processed = processed.replace(
    /\[\[FUENTE:([^\|]+)\|([^\]]+)\]\]/g,
    (_, name, url) => `[__SOURCE__${name.trim()}__SOURCE__](${url.trim()})`
  );
  
  if (webSources && webSources.length > 0) {
    processed = processed.replace(
      /\[(?:Fuente|Source|Ref)[:.]?\s*(\d+)\]|\((?:Fuente|Source)\s*(\d+)\)|\[(\d+)\](?=\s|$|[.,])/gi,
      (match, num1, num2, num3) => {
        const numStr = num1 || num2 || num3;
        const num = parseInt(numStr, 10);
        const source = webSources[num - 1];
        if (source) {
          const name = source.siteName || source.domain;
          return ` [__SOURCE__${name}__SOURCE__](${source.url})`;
        }
        return match;
      }
    );
  }
  
  return processed;
}

const purifyConfig: DOMPurify.Config = {
  ALLOWED_TAGS: [
    'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'br', 'hr',
    'ul', 'ol', 'li', 'blockquote', 'pre', 'code',
    'strong', 'em', 'b', 'i', 'u', 's', 'del', 'ins', 'mark',
    'a', 'img', 'span', 'div',
    'table', 'thead', 'tbody', 'tr', 'th', 'td',
    'math', 'mrow', 'mi', 'mo', 'mn', 'msup', 'msub', 'mfrac', 'mroot', 'msqrt', 'mtext', 'mspace', 'mtable', 'mtr', 'mtd', 'annotation', 'annotation-xml', 'semantics',
    'svg', 'path', 'circle', 'rect', 'line', 'polygon', 'polyline', 'g', 'defs', 'use', 'symbol'
  ],
  ALLOWED_ATTR: [
    'href', 'src', 'alt', 'title', 'class', 'className', 'id', 'style',
    'target', 'rel', 'width', 'height', 'loading', 'decoding',
    'colspan', 'rowspan', 'scope',
    'xmlns', 'display', 'viewBox', 'fill', 'stroke', 'd', 'strokeWidth', 'strokeLinecap', 'strokeLinejoin',
    'aria-hidden', 'data-testid'
  ],
  ALLOW_DATA_ATTR: false,
  FORBID_TAGS: ['script', 'iframe', 'object', 'embed', 'form', 'input', 'button', 'select', 'textarea'],
  FORBID_ATTR: ['onerror', 'onload', 'onclick', 'onmouseover', 'onfocus', 'onblur']
};

export function sanitizeContent(content: string): string {
  if (!content || typeof content !== 'string') return '';
  return DOMPurify.sanitize(content, purifyConfig);
}

interface MarkdownErrorBoundaryProps {
  children: ReactNode;
  fallbackContent?: string;
}

interface MarkdownErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
  lastFallbackContent?: string;
}

export class MarkdownErrorBoundary extends Component<MarkdownErrorBoundaryProps, MarkdownErrorBoundaryState> {
  constructor(props: MarkdownErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false, error: null, lastFallbackContent: props.fallbackContent };
  }

  static getDerivedStateFromError(error: Error): Partial<MarkdownErrorBoundaryState> {
    return { hasError: true, error };
  }

  static getDerivedStateFromProps(
    nextProps: MarkdownErrorBoundaryProps,
    prevState: MarkdownErrorBoundaryState
  ): Partial<MarkdownErrorBoundaryState> | null {
    if (nextProps.fallbackContent !== prevState.lastFallbackContent) {
      return {
        hasError: false,
        error: null,
        lastFallbackContent: nextProps.fallbackContent,
      };
    }
    return null;
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.warn('[MarkdownErrorBoundary] Rendering error (silent fallback):', error.message);
  }

  componentDidUpdate(prevProps: MarkdownErrorBoundaryProps) {
    if (prevProps.fallbackContent !== this.props.fallbackContent && this.state.hasError) {
      this.setState({ hasError: false, error: null });
    }
  }

  render() {
    if (this.state.hasError) {
      const content = this.props.fallbackContent || '';
      return (
        <div className="whitespace-pre-wrap break-words">
          {content}
        </div>
      );
    }

    return this.props.children;
  }
}

type GenerationState = 'analyzing' | 'structuring' | 'generating' | 'completing' | 'done';

const STATE_MESSAGES: Record<GenerationState, { text: string; progress: number }> = {
  analyzing: { text: 'Analizando solicitud...', progress: 20 },
  structuring: { text: 'Estructurando contenido...', progress: 45 },
  generating: { text: 'Generando documento...', progress: 70 },
  completing: { text: 'Finalizando...', progress: 90 },
  done: { text: 'Documento listo', progress: 100 }
};

interface DocumentGenerationLoaderProps {
  documentType: 'word' | 'excel' | 'ppt';
  title?: string;
  isComplete: boolean;
  onOpen?: () => void;
}

const DocumentGenerationLoader = memo(function DocumentGenerationLoader({ 
  documentType, 
  title, 
  isComplete,
  onOpen 
}: DocumentGenerationLoaderProps) {
  const [state, setState] = useState<GenerationState>('analyzing');
  
  useEffect(() => {
    if (isComplete) {
      setState('done');
      return;
    }
    
    const progression: GenerationState[] = ['analyzing', 'structuring', 'generating', 'completing'];
    let currentIndex = 0;
    
    const interval = setInterval(() => {
      currentIndex = Math.min(currentIndex + 1, progression.length - 1);
      setState(progression[currentIndex]);
    }, 1200);
    
    return () => clearInterval(interval);
  }, [isComplete]);
  
  const currentState = STATE_MESSAGES[state];
  
  const DocIcon = documentType === 'word' ? FileText : documentType === 'excel' ? FileSpreadsheet : Presentation;
  const iconBgColor = documentType === 'word' ? 'bg-[#2B579A]' : documentType === 'excel' ? 'bg-[#217346]' : 'bg-[#D04423]';
  
  if (isComplete) {
    return (
      <div 
        className="flex items-center gap-3.5 p-4 bg-gradient-to-r from-sky-50 to-blue-50 dark:from-sky-950/30 dark:to-blue-950/30 border border-sky-200 dark:border-sky-800 rounded-2xl cursor-pointer transition-all duration-300 hover:shadow-lg hover:shadow-sky-200/50 dark:hover:shadow-sky-900/30 hover:-translate-y-0.5 max-w-[340px] group"
        onClick={onOpen}
        data-testid="document-ready-card"
      >
        <div className="relative flex-shrink-0">
          <div className={cn("w-11 h-11 rounded-xl flex items-center justify-center", iconBgColor)}>
            <DocIcon className="w-5 h-5 text-white" />
          </div>
          <div className="absolute -bottom-1 -right-1 w-5 h-5 bg-emerald-500 rounded-full flex items-center justify-center border-2 border-white dark:border-gray-900">
            <Check className="w-3 h-3 text-white" />
          </div>
        </div>
        <div className="flex-1 min-w-0">
          <span className="font-semibold text-sm text-gray-900 dark:text-gray-100 truncate block">
            {title || 'Documento Word'}
          </span>
          <span className="text-xs text-gray-500 dark:text-gray-400">
            Documento listo â€¢ Click para abrir
          </span>
        </div>
        <ChevronRight className="w-5 h-5 text-sky-500 transition-transform group-hover:translate-x-1" />
      </div>
    );
  }
  
  return (
    <div className="bg-gradient-to-br from-slate-50 to-gray-100 dark:from-slate-900 dark:to-gray-900 border border-slate-200 dark:border-slate-700 rounded-2xl p-5 max-w-[340px] shadow-sm" data-testid="document-generation-loader">
      <div className="flex items-center gap-3.5 mb-4">
        <div className="relative flex-shrink-0">
          <div className="absolute inset-0 w-11 h-11 rounded-full bg-sky-400/20 dark:bg-sky-500/20 animate-ping" style={{ animationDuration: '2s' }} />
          <div className={cn("relative w-11 h-11 rounded-xl flex items-center justify-center", iconBgColor)}>
            <DocIcon className="w-5 h-5 text-white" />
          </div>
        </div>
        <div className="flex flex-col gap-0.5">
          <span className="font-semibold text-sm text-gray-900 dark:text-gray-100">
            Creando documento
          </span>
          <span className="text-xs text-gray-500 dark:text-gray-400 animate-pulse">
            {currentState.text}
          </span>
        </div>
      </div>
      
      <div className="flex items-center gap-2.5">
        <div className="flex-1 h-1 bg-slate-200 dark:bg-slate-700 rounded-full overflow-hidden">
          <div 
            className="h-full bg-gradient-to-r from-sky-500 to-blue-500 rounded-full transition-all duration-500 ease-out"
            style={{ width: `${currentState.progress}%` }}
          />
        </div>
        <span className="text-[11px] text-gray-400 dark:text-gray-500 tabular-nums min-w-[32px] text-right">
          {currentState.progress}%
        </span>
      </div>
      
      <div className="flex justify-center gap-1.5 mt-4">
        {[0, 1, 2].map((i) => (
          <span 
            key={i}
            className="w-1.5 h-1.5 bg-slate-300 dark:bg-slate-600 rounded-full animate-bounce"
            style={{ animationDelay: `${i * 0.15}s`, animationDuration: '1s' }}
          />
        ))}
      </div>
    </div>
  );
});

function detectDocumentJSON(content: string): { isDocument: boolean; type?: 'word' | 'excel' | 'ppt'; title?: string; isComplete: boolean } {
  const trimmed = content.trim();
  
  const typeMatch = trimmed.match(/"type"\s*:\s*"(word|excel|ppt)"/);
  if (!typeMatch) {
    const partialTypeMatch = trimmed.match(/\{\s*"type"\s*:\s*"?/);
    if (partialTypeMatch || trimmed.startsWith('{')) {
      const looksLikeDocStart = /^\s*\{\s*(?:"type"|"title"|"content")/.test(trimmed);
      if (looksLikeDocStart) {
        return { isDocument: true, isComplete: false };
      }
    }
    return { isDocument: false, isComplete: false };
  }
  
  const docType = typeMatch[1] as 'word' | 'excel' | 'ppt';
  const titleMatch = trimmed.match(/"title"\s*:\s*"([^"]+)"/);
  const title = titleMatch?.[1];
  
  const hasContent = /"content"\s*:\s*"/.test(trimmed);
  const endsWithClosingBrace = trimmed.endsWith('}');
  const isComplete = hasContent && endsWithClosingBrace;
  
  return { isDocument: true, type: docType, title, isComplete };
}

const sanitizeSchema = {
  ...defaultSchema,
  tagNames: [
    ...(defaultSchema.tagNames || []),
    "math",
    "mrow",
    "mi",
    "mo",
    "mn",
    "msup",
    "msub",
    "mfrac",
    "mroot",
    "msqrt",
    "mtext",
    "mspace",
    "mtable",
    "mtr",
    "mtd",
    "annotation",
    "annotation-xml",
    "semantics",
    "svg",
    "path",
    "circle",
    "rect",
    "line",
    "polygon",
    "polyline",
    "g",
    "defs",
    "use",
    "symbol",
  ],
  attributes: {
    ...defaultSchema.attributes,
    "*": [...(defaultSchema.attributes?.["*"] || []), "className", "class", "style"],
    math: ["xmlns", "display"],
    svg: ["xmlns", "viewBox", "width", "height", "fill", "stroke"],
    path: ["d", "fill", "stroke", "strokeWidth", "strokeLinecap", "strokeLinejoin"],
    code: ["className", "class"],
    span: ["className", "class", "style", "aria-hidden"],
    div: ["className", "class", "style"],
    img: ["src", "alt", "title", "loading", "width", "height"],
    a: ["href", "title", "target", "rel"],
    table: ["className", "class"],
    th: ["className", "class", "scope", "colSpan", "rowSpan"],
    td: ["className", "class", "colSpan", "rowSpan"],
  },
  protocols: {
    ...defaultSchema.protocols,
    src: ["http", "https", "data"],
    href: ["http", "https", "mailto", "#"],
  },
};


interface LazyImageProps {
  src?: string;
  alt?: string;
  title?: string;
  className?: string;
  maxHeight?: string;
}

const LazyImage = memo(function LazyImage({ 
  src, 
  alt, 
  title, 
  className,
  maxHeight = "400px" 
}: LazyImageProps) {
  const [loaded, setLoaded] = useState(false);
  const [error, setError] = useState(false);

  const handleLoad = useCallback(() => setLoaded(true), []);
  const handleError = useCallback(() => setError(true), []);

  if (!src) return null;
  
  // Check if this is a Gmail logo - render inline and small
  const isGmailLogo = src.includes('gmail-logo') || (alt?.toLowerCase() === 'gmail');
  
  if (isGmailLogo) {
    return (
      <img
        src={src}
        alt={alt || "Gmail"}
        title={title || "Ver en Gmail"}
        loading="eager"
        decoding="async"
        className="inline-block align-middle"
        style={{ 
          width: '1.4em', 
          height: '1.4em', 
          marginLeft: '6px', 
          verticalAlign: 'text-bottom',
          display: 'inline'
        }}
        data-testid="img-gmail-logo"
      />
    );
  }
  
  if (error) {
    return (
      <div className="flex items-center justify-center bg-muted rounded-lg p-4 my-3 text-muted-foreground text-sm">
        Error loading image
      </div>
    );
  }

  return (
    <div className="relative my-3">
      {!loaded && (
        <div className="absolute inset-0 flex items-center justify-center bg-muted rounded-lg">
          <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
        </div>
      )}
      <img
        src={src}
        alt={alt || "Image"}
        title={title}
        loading="lazy"
        onLoad={handleLoad}
        onError={handleError}
        className={cn(
          "max-w-full h-auto rounded-lg transition-opacity duration-300",
          loaded ? "opacity-100" : "opacity-0",
          className
        )}
        style={{ maxHeight }}
        data-testid="img-markdown"
      />
    </div>
  );
});

interface CodeBlockProps {
  inline?: boolean;
  className?: string;
  children?: React.ReactNode;
  onOpenDocument?: (doc: { type: 'word' | 'excel' | 'ppt'; title: string; content: string }) => void;
}

const CodeBlock = memo(function CodeBlock({ inline, className, children, onOpenDocument }: CodeBlockProps) {
  const [copied, setCopied] = useState(false);
  const match = /language-(\w+)/.exec(className || "");
  const language = match?.[1] || "";
  const codeContent = String(children).replace(/\n$/, "");

  const handleCopy = useCallback(async () => {
    try {
      await navigator.clipboard.writeText(codeContent);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error("Failed to copy:", err);
    }
  }, [codeContent]);

  if (inline) {
    return (
      <code className="px-1.5 py-0.5 rounded bg-muted text-sm font-mono">
        {children}
      </code>
    );
  }

  const docDetection = detectDocumentJSON(codeContent);
  const isDocumentLanguage = language === 'document' || language === 'json';
  
  if (docDetection.isDocument && (isDocumentLanguage || !language)) {
    const handleOpenDocument = () => {
      if (!docDetection.isComplete || !docDetection.type) return;
      
      try {
        const parsed = JSON.parse(codeContent);
        if (parsed.type && parsed.title && parsed.content) {
          let docContent = parsed.content;
          if (typeof docContent === 'string') {
            docContent = docContent.replace(/\\n/g, '\n').replace(/\\\\n/g, '\n');
          }
          onOpenDocument?.({ 
            type: parsed.type, 
            title: parsed.title, 
            content: docContent 
          });
        }
      } catch (e) {
        console.error('Failed to parse document JSON:', e);
      }
    };
    
    return (
      <div className="my-4">
        <DocumentGenerationLoader
          documentType={docDetection.type || 'word'}
          title={docDetection.title}
          isComplete={docDetection.isComplete}
          onOpen={handleOpenDocument}
        />
      </div>
    );
  }

  return (
    <div className="relative group my-4">
      {language && (
        <div className="absolute top-0 left-0 px-3 py-1 text-xs font-mono text-muted-foreground bg-muted/50 rounded-tl-lg rounded-br-lg">
          {language}
        </div>
      )}
      <button
        onClick={handleCopy}
        className="absolute top-2 right-2 p-1.5 rounded-md bg-muted/80 hover:bg-muted opacity-0 group-hover:opacity-100 transition-opacity"
        aria-label={copied ? "Copied" : "Copy code"}
        data-testid="button-copy-code"
      >
        {copied ? (
          <Check className="h-4 w-4 text-green-500" />
        ) : (
          <Copy className="h-4 w-4 text-muted-foreground" />
        )}
      </button>
      <pre className={cn("rounded-lg overflow-x-auto p-4 pt-8 bg-muted/30", className)}>
        <code className={cn("text-sm font-mono", className)}>{children}</code>
      </pre>
    </div>
  );
});

interface TableWrapperProps {
  children?: React.ReactNode;
}

const TableWrapper = memo(function TableWrapper({ children }: TableWrapperProps) {
  const [copied, setCopied] = useState(false);
  const [isExpanded, setIsExpanded] = useState(false);
  const tableRef = useRef<HTMLDivElement>(null);

  const handleCopy = useCallback(async () => {
    if (!tableRef.current) return;
    const table = tableRef.current.querySelector('table');
    if (!table) return;
    
    const rows = table.querySelectorAll('tr');
    const text = Array.from(rows).map(row => {
      const cells = row.querySelectorAll('th, td');
      return Array.from(cells).map(cell => cell.textContent?.trim() || '').join('\t');
    }).join('\n');
    
    try {
      await navigator.clipboard.writeText(text);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error('Failed to copy table:', err);
    }
  }, []);

  const handleDownload = useCallback(() => {
    if (!tableRef.current) return;
    const table = tableRef.current.querySelector('table');
    if (!table) return;
    
    const rows = table.querySelectorAll('tr');
    const csv = Array.from(rows).map(row => {
      const cells = row.querySelectorAll('th, td');
      return Array.from(cells).map(cell => {
        const text = cell.textContent?.trim() || '';
        return text.includes(',') ? `"${text}"` : text;
      }).join(',');
    }).join('\n');
    
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'tabla.csv';
    link.click();
    URL.revokeObjectURL(url);
  }, []);

  return (
    <div 
      ref={tableRef}
      className={cn(
        "relative group my-4",
        isExpanded && "fixed inset-4 z-50 bg-background rounded-lg border shadow-2xl overflow-auto p-4"
      )}
    >
      <div className="absolute top-2 right-2 flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity z-10">
        <button
          onClick={handleCopy}
          className="p-1.5 rounded-md bg-muted/80 hover:bg-muted border border-border/50"
          title={copied ? "Copiado" : "Copiar tabla"}
          data-testid="button-copy-table"
        >
          {copied ? (
            <Check className="h-4 w-4 text-green-500" />
          ) : (
            <Copy className="h-4 w-4 text-muted-foreground" />
          )}
        </button>
        <button
          onClick={handleDownload}
          className="p-1.5 rounded-md bg-muted/80 hover:bg-muted border border-border/50"
          title="Descargar CSV"
          data-testid="button-download-table"
        >
          <Download className="h-4 w-4 text-muted-foreground" />
        </button>
        <button
          onClick={() => setIsExpanded(!isExpanded)}
          className="p-1.5 rounded-md bg-muted/80 hover:bg-muted border border-border/50"
          title={isExpanded ? "Minimizar" : "Expandir"}
          data-testid="button-expand-table"
        >
          {isExpanded ? (
            <Minimize2 className="h-4 w-4 text-muted-foreground" />
          ) : (
            <Maximize2 className="h-4 w-4 text-muted-foreground" />
          )}
        </button>
      </div>
      <div className="overflow-x-auto">
        <table className="min-w-full border-collapse border border-border rounded-lg" data-testid="table-markdown">
          {children}
        </table>
      </div>
    </div>
  );
});

interface TableComponents {
  table: React.ComponentType<{ children?: React.ReactNode }>;
  thead: React.ComponentType<{ children?: React.ReactNode }>;
  tbody: React.ComponentType<{ children?: React.ReactNode }>;
  tr: React.ComponentType<{ children?: React.ReactNode }>;
  th: React.ComponentType<{ children?: React.ReactNode }>;
  td: React.ComponentType<{ children?: React.ReactNode }>;
}

const tableComponents: TableComponents = {
  table: TableWrapper,
  thead: ({ children }) => <thead className="bg-muted/50">{children}</thead>,
  tbody: ({ children }) => <tbody className="divide-y divide-border">{children}</tbody>,
  tr: ({ children }) => <tr className="hover:bg-muted/30 transition-colors">{children}</tr>,
  th: ({ children }) => (
    <th className="px-4 py-2 text-left text-sm font-semibold border border-border">{children}</th>
  ),
  td: ({ children }) => (
    <td className="px-4 py-2 text-sm border border-border">{children}</td>
  ),
};

interface InteractiveCodeBlockProps {
  inline?: boolean;
  className?: string;
  children?: React.ReactNode;
  runnable?: boolean;
  editable?: boolean;
  onEdit?: (code: string) => void;
}

const InteractiveCodeBlock = memo(function InteractiveCodeBlock({
  inline,
  className,
  children,
  runnable = true,
  editable = false,
  onEdit,
}: InteractiveCodeBlockProps) {
  const match = /language-(\w+)/.exec(className || "");
  const language = match?.[1] || "text";
  const codeContent = String(children).replace(/\n$/, "");

  const { execute, isRunning, result, errorLines, reset } = useSandboxExecution();

  const isRunnable = runnable && isLanguageRunnable(language);

  const handleRun = useCallback(async () => {
    await execute(codeContent, language);
  }, [execute, codeContent, language]);

  const handleEdit = useCallback(() => {
    onEdit?.(codeContent);
  }, [onEdit, codeContent]);

  if (inline) {
    return (
      <code className="px-1.5 py-0.5 rounded bg-muted text-sm font-mono">
        {children}
      </code>
    );
  }

  return (
    <div className="my-4 space-y-2">
      <CodeBlockShell
        code={codeContent}
        language={language}
        showLineNumbers={true}
        maxHeight="400px"
        errorLines={errorLines}
        runnable={isRunnable}
        editable={editable}
        onRun={isRunnable ? handleRun : undefined}
        onEdit={editable ? handleEdit : undefined}
      />
      {isRunning && (
        <div className="flex items-center gap-2 text-sm text-muted-foreground px-3 py-2 bg-muted/30 rounded-md">
          <Loader2 className="h-4 w-4 animate-spin" />
          <span>Running...</span>
        </div>
      )}
      {result && !isRunning && (
        <div className="rounded-md border border-zinc-800 bg-zinc-950 overflow-hidden">
          <div className="px-3 py-1.5 bg-zinc-900 border-b border-zinc-800 flex items-center justify-between">
            <span className="text-xs text-zinc-400 font-mono">
              Output {result.usedFallback && "(local fallback)"}
            </span>
            <button
              onClick={reset}
              className="text-xs text-zinc-500 hover:text-zinc-300 transition-colors"
              data-testid="button-clear-output"
            >
              Clear
            </button>
          </div>
          <div className="p-3 font-mono text-sm overflow-x-auto">
            {result.run.stdout && (
              <pre className="text-green-400 whitespace-pre-wrap">{result.run.stdout}</pre>
            )}
            {result.run.stderr && (
              <pre className="text-red-400 whitespace-pre-wrap">{result.run.stderr}</pre>
            )}
            {!result.run.stdout && !result.run.stderr && (
              <span className="text-zinc-500 italic">No output</span>
            )}
          </div>
          {result.run.code !== 0 && (
            <div className="px-3 py-1.5 bg-red-500/10 border-t border-zinc-800 text-xs text-red-400">
              Exit code: {result.run.code}
            </div>
          )}
        </div>
      )}
    </div>
  );
});

export interface MarkdownRendererProps {
  content: string;
  className?: string;
  imageMaxHeight?: string;
  enableMath?: boolean;
  enableCodeHighlight?: boolean;
  enableGfm?: boolean;
  sanitize?: boolean;
  enableInteractiveCode?: boolean;
  interactiveCodeEditable?: boolean;
  onCodeEdit?: (code: string) => void;
  onOpenDocument?: (doc: { type: 'word' | 'excel' | 'ppt'; title: string; content: string }) => void;
  customComponents?: Record<string, React.ComponentType<any>>;
  webSources?: Array<{ url: string; siteName?: string; domain: string }>;
}

function isSimpleContent(text: string): boolean {
  if (!text || text.length < 5) return true;
  const hasCodeBlocks = /```[\s\S]*```|`[^`]+`/.test(text);
  const hasMath = /\$\$[\s\S]+?\$\$|\$[^\$\n]+?\$|\\[[\s\S]+?\\]|\\([\s\S]+?\\)/.test(text);
  const hasComplexMarkdown = /^#{1,6}\s|^\s*[-*+]\s|\|.*\|.*\||!\[.*\]\(.*\)/m.test(text);
  const hasLinks = /\[.*?\]\(.*?\)/.test(text);
  const hasBold = /\*\*[^*]+\*\*|__[^_]+__/.test(text);
  const hasItalic = /\*[^*]+\*|_[^_]+_/.test(text);
  const hasSourceBadges = /__SOURCE__/.test(text);
  return !hasCodeBlocks && !hasMath && !hasComplexMarkdown && !hasLinks && !hasBold && !hasItalic && !hasSourceBadges;
}

function SafeSimpleRenderer({ content, className }: { content: string; className?: string }) {
  const paragraphs = content.split(/\n\n+/).filter(p => p.trim());
  return (
    <div className={cn("prose prose-sm dark:prose-invert max-w-none", className)} data-testid="markdown-renderer-simple">
      {paragraphs.map((p, i) => (
        <p key={i} className="mb-3 leading-relaxed whitespace-pre-wrap">{p}</p>
      ))}
    </div>
  );
}

export const MarkdownRenderer = memo(function MarkdownRenderer({
  content,
  className,
  imageMaxHeight = "400px",
  enableMath = true,
  enableCodeHighlight = true,
  enableGfm = true,
  sanitize = true,
  enableInteractiveCode = false,
  interactiveCodeEditable = false,
  onCodeEdit,
  onOpenDocument,
  customComponents = {},
  webSources,
}: MarkdownRendererProps) {
  const [renderError, setRenderError] = useState<Error | null>(null);

  const processedContent = useMemo(() => {
    if (!content) return "";
    try {
      let processed = content;
      processed = preprocessSourceBadges(processed, webSources);
      const sanitized = sanitize ? sanitizeContent(processed) : processed;
      return enableMath ? preprocessMathInMarkdown(sanitized) : sanitized;
    } catch (error) {
      console.error('[MarkdownRenderer] Content processing error:', error);
      return content;
    }
  }, [content, enableMath, sanitize, webSources]);

  useEffect(() => {
    setRenderError(null);
  }, [processedContent]);

  const isSimple = useMemo(() => isSimpleContent(content || ''), [content]);

  const remarkPlugins = useMemo(() => {
    const plugins: any[] = [];
    if (enableGfm && !isSimple) plugins.push(remarkGfm);
    if (enableMath && !isSimple) plugins.push(remarkMath);
    return plugins;
  }, [enableGfm, enableMath, isSimple]);

  const rehypePlugins = useMemo(() => {
    const plugins: any[] = [];
    if (isSimple) return plugins;
    if (sanitize && !enableMath) {
      plugins.push([rehypeSanitize, sanitizeSchema]);
    }
    if (enableMath) {
      plugins.push([rehypeKatex, { 
        throwOnError: false, 
        errorColor: '#cc0000',
        strict: false,
        trust: false,
        output: 'htmlAndMathml'
      }]);
    }
    if (enableCodeHighlight) plugins.push(rehypeHighlight);
    return plugins;
  }, [enableMath, enableCodeHighlight, sanitize, isSimple]);

  const CodeComponent = useMemo(() => {
    if (enableInteractiveCode) {
      return (props: any) => (
        <InteractiveCodeBlock
          {...props}
          editable={interactiveCodeEditable}
          onEdit={onCodeEdit}
        />
      );
    }
    return (props: any) => <CodeBlock {...props} onOpenDocument={onOpenDocument} />;
  }, [enableInteractiveCode, interactiveCodeEditable, onCodeEdit, onOpenDocument]);

  const components = useMemo(() => ({
    code: CodeComponent,
    img: (props: any) => <LazyImage {...props} maxHeight={imageMaxHeight} />,
    p: ({ children }: { children?: React.ReactNode }) => <p className="mb-3 leading-relaxed">{children}</p>,
    a: ({ href, children }: { href?: string; children?: React.ReactNode }) => {
      const childText = typeof children === 'string' ? children : 
        (Array.isArray(children) && typeof children[0] === 'string' ? children[0] : '');
      
      const sourceMatch = childText.match(/^__SOURCE__(.+)__SOURCE__$/);
      if (sourceMatch && href) {
        return <InlineSourceBadge name={sourceMatch[1]} url={href} />;
      }
      
      return (
        <a
          href={href}
          target="_blank"
          rel="noopener noreferrer"
          className="text-sky-500 hover:text-sky-600 hover:underline transition-colors"
          data-testid="link-markdown"
        >
          {children}
        </a>
      );
    },
    ul: ({ children }: { children?: React.ReactNode }) => (
      <ul className="list-disc list-inside mb-3 space-y-1">{children}</ul>
    ),
    ol: ({ children }: { children?: React.ReactNode }) => (
      <ol className="list-decimal list-inside mb-3 space-y-1">{children}</ol>
    ),
    li: ({ children }: { children?: React.ReactNode }) => <li className="ml-2">{children}</li>,
    h1: ({ children }: { children?: React.ReactNode }) => (
      <h1 className="text-xl font-bold mb-3 mt-4">{children}</h1>
    ),
    h2: ({ children }: { children?: React.ReactNode }) => (
      <h2 className="text-lg font-bold mb-2 mt-3">{children}</h2>
    ),
    h3: ({ children }: { children?: React.ReactNode }) => (
      <h3 className="text-base font-semibold mb-2 mt-2">{children}</h3>
    ),
    h4: ({ children }: { children?: React.ReactNode }) => (
      <h4 className="text-sm font-semibold mb-2 mt-2">{children}</h4>
    ),
    blockquote: ({ children }: { children?: React.ReactNode }) => (
      <blockquote className="border-l-4 border-muted-foreground/30 pl-4 italic my-3 text-muted-foreground">
        {children}
      </blockquote>
    ),
    hr: () => <hr className="my-4 border-border" />,
    ...tableComponents,
    ...customComponents,
  }), [imageMaxHeight, customComponents, CodeComponent]);

  if (!processedContent) {
    return null;
  }

  if (renderError || isSimple) {
    return <SafeSimpleRenderer content={processedContent || content} className={className} />;
  }

  return (
    <div className={cn("prose prose-sm dark:prose-invert max-w-none", className)} data-testid="markdown-renderer">
      <ReactMarkdown
        remarkPlugins={remarkPlugins}
        rehypePlugins={rehypePlugins}
        components={components}
      >
        {processedContent}
      </ReactMarkdown>
    </div>
  );
});

export default MarkdownRenderer;
