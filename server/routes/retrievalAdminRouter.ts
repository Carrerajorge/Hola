import { Router, Request, Response, NextFunction } from "express";
import { responseCache } from "../agent/webtool/responseCache";
import { retrievalMetrics } from "../agent/webtool/retrievalMetrics";
import { isAuthenticated } from "../replit_integrations/auth/replitAuth";
import { authStorage } from "../replit_integrations/auth/storage";
import { storage } from "../storage";

interface ErrorTrackingEntry {
  domain: string;
  errorType: "blocked" | "rate_limited" | "timeout" | "fetch_error" | "browser_error";
  count: number;
  lastOccurred: number;
}

class RetrievalErrorTracker {
  private errors: Map<string, ErrorTrackingEntry> = new Map();
  private maxEntries = 500;

  recordError(domain: string, errorType: ErrorTrackingEntry["errorType"]): void {
    const key = `${domain}:${errorType}`;
    const existing = this.errors.get(key);
    
    if (existing) {
      existing.count++;
      existing.lastOccurred = Date.now();
    } else {
      if (this.errors.size >= this.maxEntries) {
        const oldestKey = this.findOldestEntry();
        if (oldestKey) this.errors.delete(oldestKey);
      }
      
      this.errors.set(key, {
        domain,
        errorType,
        count: 1,
        lastOccurred: Date.now(),
      });
    }
  }

  private findOldestEntry(): string | null {
    let oldestKey: string | null = null;
    let oldestTime = Infinity;
    
    for (const [key, entry] of this.errors.entries()) {
      if (entry.lastOccurred < oldestTime) {
        oldestTime = entry.lastOccurred;
        oldestKey = key;
      }
    }
    
    return oldestKey;
  }

  getSummary(windowMs: number = 3600000): {
    domainsBlocked: number;
    rateLimitErrors: number;
    timeoutErrors: number;
    fetchErrors: number;
    browserErrors: number;
    topErrorDomains: Array<{ domain: string; errorType: string; count: number }>;
  } {
    const cutoff = Date.now() - windowMs;
    let domainsBlocked = 0;
    let rateLimitErrors = 0;
    let timeoutErrors = 0;
    let fetchErrors = 0;
    let browserErrors = 0;
    const recentErrors: Array<{ domain: string; errorType: string; count: number }> = [];

    for (const entry of this.errors.values()) {
      if (entry.lastOccurred >= cutoff) {
        recentErrors.push({
          domain: entry.domain,
          errorType: entry.errorType,
          count: entry.count,
        });

        switch (entry.errorType) {
          case "blocked":
            domainsBlocked += entry.count;
            break;
          case "rate_limited":
            rateLimitErrors += entry.count;
            break;
          case "timeout":
            timeoutErrors += entry.count;
            break;
          case "fetch_error":
            fetchErrors += entry.count;
            break;
          case "browser_error":
            browserErrors += entry.count;
            break;
        }
      }
    }

    const topErrorDomains = recentErrors
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);

    return {
      domainsBlocked,
      rateLimitErrors,
      timeoutErrors,
      fetchErrors,
      browserErrors,
      topErrorDomains,
    };
  }

  clear(): void {
    this.errors.clear();
  }
}

export const retrievalErrorTracker = new RetrievalErrorTracker();

async function requireAdmin(req: Request, res: Response, next: NextFunction) {
  try {
    const userReq = req as any;
    if (!userReq.user?.claims?.sub) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const user = await authStorage.getUser(userReq.user.claims.sub);
    if (!user || user.role !== "admin") {
      await storage.createAuditLog({
        action: "admin_access_denied",
        resource: "retrieval_admin",
        details: { userId: userReq.user.claims.sub, path: req.path }
      });
      return res.status(403).json({ error: "Admin access required" });
    }
    next();
  } catch (error) {
    return res.status(500).json({ error: "Authorization check failed" });
  }
}

export function createRetrievalAdminRouter(): Router {
  const router = Router();

  router.get("/retrieval-status", isAuthenticated, requireAdmin, async (req: Request, res: Response) => {
    try {
      const windowMs = req.query.window 
        ? parseInt(req.query.window as string, 10) 
        : 3600000;

      const cacheStats = responseCache.getStats();
      const slaReport = retrievalMetrics.getSLAReport(windowMs);
      const methodBreakdown = retrievalMetrics.getMethodBreakdown();
      const errorSummary = retrievalErrorTracker.getSummary(windowMs);
      const latencyHistogram = retrievalMetrics.getLatencyHistogram();

      const response = {
        timestamp: new Date().toISOString(),
        windowMs,
        cache: {
          entries: cacheStats.entries,
          hits: cacheStats.hits,
          misses: cacheStats.misses,
          hitRate: cacheStats.hitRate,
          memoryUsageMb: cacheStats.memoryUsageMb,
          oldestEntryAgeMs: cacheStats.oldestEntryAge,
        },
        sla: {
          fetchP95Ms: slaReport.fetchP95Ms,
          browserP95Ms: slaReport.browserP95Ms,
          overallP95Ms: slaReport.overallP95Ms,
          cacheHitRate: slaReport.cacheHitRate,
          avgRelevanceScore: slaReport.avgRelevanceScore,
          avgSourcesCount: slaReport.avgSourcesCount,
          successRate: slaReport.successRate,
          totalRequests: slaReport.totalRequests,
          compliance: slaReport.slaCompliance,
        },
        methodBreakdown,
        errors: errorSummary,
        latencyHistogram,
        health: {
          status: slaReport.slaCompliance.overall ? "healthy" : "degraded",
          issues: getHealthIssues(slaReport, cacheStats),
        },
      };

      res.json(response);
    } catch (error) {
      console.error("[RetrievalAdmin] Error fetching retrieval status:", error);
      res.status(500).json({ 
        error: "Failed to fetch retrieval status",
        message: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });

  return router;
}

function getHealthIssues(slaReport: any, cacheStats: any): string[] {
  const issues: string[] = [];

  if (!slaReport.slaCompliance.fetchP95) {
    issues.push(`Fetch P95 latency (${slaReport.fetchP95Ms}ms) exceeds SLA threshold`);
  }
  if (!slaReport.slaCompliance.browserP95) {
    issues.push(`Browser P95 latency (${slaReport.browserP95Ms}ms) exceeds SLA threshold`);
  }
  if (!slaReport.slaCompliance.cacheHitRate) {
    issues.push(`Cache hit rate (${(slaReport.cacheHitRate * 100).toFixed(1)}%) below minimum`);
  }
  if (!slaReport.slaCompliance.relevanceScore) {
    issues.push(`Average relevance score (${slaReport.avgRelevanceScore.toFixed(2)}) below minimum`);
  }
  if (!slaReport.slaCompliance.sourcesCount) {
    issues.push(`Average sources count (${slaReport.avgSourcesCount.toFixed(1)}) below minimum`);
  }
  if (cacheStats.memoryUsageMb > 40) {
    issues.push(`Cache memory usage (${cacheStats.memoryUsageMb.toFixed(1)}MB) approaching limit`);
  }

  return issues;
}
